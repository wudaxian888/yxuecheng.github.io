<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Redux状态管理方法与实例]]></title>
      <url>%2F2017%2F02%2F18%2FRedux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[Redux状态管理方法与实例 虽然官方文档上说只需几分钟就能上手 Redux，但是我个人认为即便你看个两三天也可能上手不了，因为文档里面的知识点不仅数量较多，而且还艰涩难懂，不结合一些实例来看很难用于实际项目中去 前言虽然官方文档上说只需几分钟就能上手 Redux，但是我个人认为即便你看个两三天也可能上手不了，因为文档里面的知识点不仅数量较多，而且还艰涩难懂，不结合一些实例来看很难用于实际项目中去。但是不要担心自己学不会，这不我就给大家带来了这篇干货，也是我学习Redux的心得体验。那么下面我就将介绍如何利用Redux来管理你的React项目了，而这里我主要教你构建的是基于React + Redux + React-Router的方法，这也是官方文档里介绍的比较少但是项目中却必备的知识点。 项目目录首先，一个基于React + Redux + React-Router的项目目录举例1234567891011121314151617├── README.md├── app│ ├── actions│ ├── components│ ├── constants│ ├── containers│ ├── fetch│ ├── index.jsx│ ├── reducers│ ├── routes.jsx│ └── store├── fis-conf.js├── index.html├── mock├── node_modules├── static└── tree.txt 入口文件配置在webpack的配置项中，我们需要一个或多个入口文件，这里我就不展示关于package.json及webpack.config.js的文件配置，最后我会提供整个项目的下载链接供大家参考。这里我主要介绍下入口文件index.js的配置说明。123456789101112131415161718192021222324252627282930import React from 'react' // 引入Reactimport &#123; render &#125; from 'react-dom' // 引入render方法import &#123; Provider &#125; from 'react-redux' // 利用Provider可以使我们的 store 能为下面的组件所用import &#123; Router, browserHistory &#125; from 'react-router' // Browser history 是由 React Router 创建浏览器应用推荐的 historyimport &#123; syncHistoryWithStore &#125; from 'react-router-redux' // 利用react-router-redux提供的syncHistoryWithStore我们可以结合store同步导航事件import finalCreateStore from './store/configureStore' //引入增强后的storeimport DevTools from './containers/DevTools' // 引入Redux调试工具DevToolsimport reducer from './reducers' // 引入reducers集合import routes from './routes' // 引入路由配置import './assets/css/bootstrap.min.css' // 引入样式文件// 给增强后的store传入reducerconst store = finalCreateStore(reducer)// 创建一个增强版的history来结合store同步导航事件const history = syncHistoryWithStore(browserHistory, store)render( &#123;/* 利用Provider包裹页面 */&#125; &lt;Provider store=&#123;store&#125;&gt; &lt;div&gt; &#123;/* 渲染根路由 */&#125; &lt;Router history=&#123;history&#125; routes=&#123;routes&#125; /&gt; &#123;/* 渲染调试组件 */&#125; &lt;DevTools /&gt; &lt;/div&gt; &lt;/Provider&gt;, document.getElementById('mount')) 在入口文件中我们尽量只需要保留基本的东西，其余的配置代码我们可以放到相应的配置文件中去，比如路由、reducers及store的配置等。这里我都把它们放置到了独立的js中，只在入口文件中通过import引入，这样管理和维护起来会非常方便，但也会相应增加理解的难度，然而一旦上手就会很容易。那么接下来我们再来看下store配置吧。 store配置123456789101112131415161718import thunk from 'redux-thunk' // redux-thunk 支持 dispatch function，并且可以异步调用它import createLogger from 'redux-logger' // 利用redux-logger打印日志import &#123; createStore, applyMiddleware, compose &#125; from 'redux' // 引入redux createStore、中间件及compose import DevTools from '../containers/DevTools' // 引入DevTools调试组件// 调用日志打印方法const loggerMiddleware = createLogger()// 创建一个中间件集合const middleware = [thunk, loggerMiddleware]// 利用compose增强store，这个 store 与 applyMiddleware 和 redux-devtools 一起使用const finalCreateStore = compose( applyMiddleware(...middleware), DevTools.instrument(),)(createStore)export default finalCreateStore 这里我们需要了解中间件（Middleware）的概念。middleware 是指可以被嵌入在框架接收请求到产生响应过程之中的代码，你可以在一个项目中使用多个独立的第三方 middleware，如上面的redux-thunk和redux-logger。详细资料请参考官方文档：http://cn.redux.js.org/docs/advanced/Mid… 路由配置上面的入口文件配置中我们把路由配置部分单独放到了routes.js的文件中，这里我们就来看下其配置：12345678910111213import React from 'react' // 引入reactimport &#123; Route, IndexRoute &#125; from 'react-router' // 引入react路由import &#123; App, Home, Foo, Bar, Antd &#125; from './containers' // 引入各容器组件export default ( &lt;Route path="/" component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125;/&gt; &lt;Route path="index" component=&#123;Home&#125;/&gt; &lt;Route path="foo" component=&#123;Foo&#125;/&gt; &lt;Route path="bar" component=&#123;Bar&#125;/&gt; &lt;Route path="antd" component=&#123;Antd&#125;/&gt; &lt;/Route&gt;) 这里的路由配置和不使用redux时候是一样的，唯一需要了解的是容器组件和展示组件的概念。上面配置文件中的路由加载的组件都可以认为是容器组件。 顾名思义，展示组件包含在容器组件中，只用作页面展示，不会定义数据如何读取如何改变，只通过this.props接受数据和回调函数； 而容器组件中包含各展示组件的数据，即Props，它们为展示组件或其他组件提供数据和方法。 根组件配置我们应该把它们放在不同的文件夹中，以示区别，如上面“项目目录”中的containers和components文件夹分别存放容器组件和展示组件。具体说明可以参考文章：http://www.jianshu.com/p/6fa2b21f5df3123456789101112131415161718192021222324252627282930313233343536373839import React, &#123; Component &#125; from 'react' // 引入Reactimport &#123; Link &#125; from 'react-router' // 引入Link处理导航跳转export default class App extends Component &#123; render() &#123; return( &lt;div&gt; &lt;nav className="navbar navbar-default"&gt; &lt;div className="container-fluid"&gt; &lt;div className="navbar-header"&gt; &lt;span className="navbar-brand" href="#"&gt; &lt;Link to="/"&gt;Redux&lt;/Link&gt; &lt;/span&gt; &lt;/div&gt; &lt;ul className="nav navbar-nav"&gt; &lt;li&gt; &lt;Link to="/index" activeStyle=&#123;&#123;color: '#555', backgroundColor: '#e7e7e7'&#125;&#125;&gt;计数器&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/foo" activeStyle=&#123;&#123;color: '#555', backgroundColor: '#e7e7e7'&#125;&#125;&gt;静态数据&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/bar" activeStyle=&#123;&#123;color: '#555', backgroundColor: '#e7e7e7'&#125;&#125;&gt;动态数据&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/antd" activeStyle=&#123;&#123;color: '#555', backgroundColor: '#e7e7e7'&#125;&#125;&gt;结合antd&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div className="panel panel-default"&gt; &lt;div className="panel-body"&gt; &#123; this.props.children &#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 整个根组件App.js主要渲染了整个应用的导航和可变区域，这其实和Redux没有关系。需要注意的是to中的URL地址需要和routes.js中的path地址名称一致。 写到这里还没有介绍Redux中的Action及Reducer的配置，那么接下来就来介绍下。 Reducer配置12345678910111213141516171819202122232425262728293031323334353637383940414243// reducers/count.jsimport &#123; INCREASE, DECREASE, GETSUCCESS, REFRESHDATA &#125; from '../constants' // 引入action类型常量名// 初始化state数据const initialState = &#123; number: 1, lists: [ &#123;text: '整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。'&#125;, &#123;text: '惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。'&#125;, &#123;text: '为了描述 action 如何改变 state tree ，你需要编写 reducers。'&#125;, &#123;text: '就是这样，现在你应该明白 Redux 是怎么回事了。'&#125; ], data: []&#125;// 通过dispatch action进入export default function update(state = initialState, action) &#123; // 根据不同的action type进行state的更新 switch(action.type) &#123; case INCREASE: return Object.assign(&#123;&#125;, state, &#123; number: state.number + action.amount &#125;) break case DECREASE: return Object.assign(&#123;&#125;, state, &#123; number: state.number - action.amount &#125;) break case GETSUCCESS: return Object.assign(&#123;&#125;, state, &#123; data: action.json &#125;) case REFRESHDATA: return Object.assign(&#123;&#125;, state, &#123; data: [] &#125;) default: return state &#125;&#125;// reducers/index.jsimport &#123; combineReducers &#125; from 'redux' // 利用combineReducers 合并reducersimport &#123; routerReducer &#125; from 'react-router-redux' // 将routerReducer一起合并管理import update from './count' // 引入update这个reducerexport default combineReducers(&#123; update, routing: routerReducer&#125;) 这里我们主要需要了解如何通过combineReducers来合并reducers，同时在进入reducer方法后我们必须返回一个state的处理结果来更新state状态，否则会报错。还需注意的是在合并reducers的时候，需要加上routerReducer这个由“react-router-redux”提供的reducer来管理路由的状态更新。 容器组件上文提到了容器组件和展示组件的区别和含义，这里我们需要在容器组件使用connect来搭配Redux来进行状态管理，这是很关键的一步。 123456789101112131415161718192021222324252627282930313233343536373839import React, &#123; Component, PropTypes &#125; from 'react' // 引入Reactimport &#123; connect &#125; from 'react-redux' // 引入connect import List from '../components/List' // 引入展示组件Listexport default class Foo extends Component &#123; render() &#123; // 通过this.props获取到lists的值 const &#123; lists &#125; = this.props return( &lt;div&gt; &lt;ul className="list-group"&gt; &#123;将值传入展示组件&#125; &#123; lists.map((e, index) =&gt; &lt;List text=&#123;e.text&#125; key=&#123;index&#125;&gt;&lt;/List&gt; )&#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;// 验证组件中的参数类型Foo.propTypes = &#123; lists: PropTypes.arrayOf(PropTypes.shape(&#123; text: PropTypes.string.isRequired &#125;).isRequired).isRequired&#125;// 获取state中的lists值const getList = state =&gt; &#123; return &#123; lists: state.update.lists &#125;&#125;// 利用connect将组件与Redux绑定起来export default connect(getList)(Foo) 在容器组件中我们需要获取state中的初始状态的时候，我们需要使用connect。任何一个从 connect() 包装好的组件都可以得到一个 dispatch 方法作为组件的 props，以及得到全局 state 中所需的任何内容。connect() 的唯一参数是 selector。此方法可以从 Redux store 接收到全局的 state，然后返回组件中需要的 props。详资料请参考文档：http://cn.redux.js.org/docs/basics/Usage… 展示组件上面的容器组件中引入了一个展示组件List，我们来看下它的代码： 12345678910111213import React, &#123; Component, PropTypes &#125; from 'react'export default class List extends Component &#123; render() &#123; return( &lt;li className="list-group-item"&gt;&#123;this.props.text&#125;&lt;/li&gt; ) &#125;&#125;List.propTypes = &#123; text: PropTypes.string.isRequired&#125; 从中我们可以发现，展示组件没有connect的方法，数据是通过this.props来获取的，这样的方式能够是数据的变化清晰可查，便于管理和维护。 部分转载自 看完完成如下demo哦~ rep 地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[随笔]]></title>
      <url>%2F2017%2F02%2F18%2F%E9%9A%8F%E7%AC%942-18%2F</url>
      <content type="text"><![CDATA[随便说几句 这段时间一直宅在学习Redux，看了好几遍文档，结合一些例子，才hhhhhhhhhhhh弄明白，当然很浅显 也在GitHub上找一些demo就研究一下，快毕业了，抓紧学点东西吧 每天有猫狗的陪伴，解锁了很多学习姿势，时而坐着，时而趴着 ….. ;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js单线程的深入分析]]></title>
      <url>%2F2017%2F02%2F15%2Fjs%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[js单线程的深入分析学习前端时看过的一篇博客比较好~防迷路链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redux学习]]></title>
      <url>%2F2017%2F02%2F14%2FReact-Redux%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[之前做过的Fis3+Es6+Smarty+Tmpl 项目实战；数据渲染还是传统的DOM依赖，用户留言同步更新留言量需要重新渲染，性能一般，现在React + Redux 这么火，作为快要毕业的我也需要学习一下，因为很多公司都要求了，蓝瘦~ 零、你可能不需要 Redux以下可能不需要使用 Redux。1234用户的使用方式非常简单用户之间没有协作不需要与服务器大量交互，也没有使用 WebSocket视图层（View）只从单一来源获取数据 以下这些情况才是 Redux 的适用场景：多交互、多数据源。1234某个组件的状态，需要共享某个状态需要在任何地方都可以拿到一个组件需要改变全局状态一个组件需要改变另一个组件的状态 设计思想Redux 的设计思想很简单，就两句话。12Web 应用是一个状态机，视图与状态是一一对应的。所有的状态，保存在一个对象里面。 请务必记住这两句话，下面就是详细解释。 基本概念和 APIStoreStore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。Redux 提供createStore这个函数，用来生成 Store。12import &#123; createStore &#125; from 'redux';const store = createStore(fn); 上面代码中，createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。 StateStore对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。当前时刻的 State，可以通过store.getState()拿到。1234import &#123; createStore &#125; from 'redux';const store = createStore(fn);const state = store.getState(); Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。 ActionState 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置，社区有一个规范可以参考。1234const action = &#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;; 上面代码中，Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux。可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。 Action CreatorView 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。12345678const ADD_TODO = '添加 TODO';function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125; const action = addTodo(‘Learn Redux’);上面代码中，addTodo函数就是一个 Action Creator。 store.dispatch()store.dispatch()是 View 发出 Action 的唯一方法。 1234567import &#123; createStore &#125; from 'redux';const store = createStore(fn);store.dispatch(&#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;); 上面代码中，store.dispatch接受一个 Action 对象作为参数，将它发送出去。结合 Action Creator，这段代码可以改写如下。1store.dispatch(addTodo('Learn Redux')); ReducerStore 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。 1234const reducer = function (state, action) &#123;// ...return new_state;&#125;; 整个应用的初始状态，可以作为 State 的默认值。下面是一个实际的例子。 1234567891011121314const defaultState = 0;const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case 'ADD': return state + action.payload; default: return state; &#125;&#125;;const state = reducer(1, &#123; type: 'ADD', payload: 2&#125;); 上面代码中，reducer函数收到名为ADD的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。12import &#123; createStore &#125; from 'redux';const store = createStore(reducer); 上面代码中，createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。为什么这个函数叫做 Reducer 呢？因为它可以作为数组的reduce方法的参数。请看下面的例子，一系列 Action 对象按照顺序作为一个数组。 123456const actions = [ &#123; type: 'ADD', payload: 0 &#125;, &#123; type: 'ADD', payload: 1 &#125;, &#123; type: 'ADD', payload: 2 &#125;];const total = actions.reduce(reducer, 0); // 3 上面代码中，数组actions表示依次有三个 Action，分别是加0、加1和加2。数组的reduce方法接受 Reducer 函数作为参数，就可以直接得到最终的状态3。 store.subscribe()Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。1234import &#123; createStore &#125; from 'redux';const store = createStore(reducer);store.subscribe(listener); 显然，只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。store.subscribe方法返回一个函数，调用这个函数就可以解除监听。12345let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe(); 工作流程 首先，用户发出 Action。1store.dispatch(action); 然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。1let nextState = todoApp(previousState, action); State 一旦有变化，Store 就会调用监听函数。 // 设置监听函数1store.subscribe(listener); listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。1234function listerner() &#123; let newState = store.getState(); component.setState(newState); &#125; 实例：计数器下面我们来看一个最简单的实例。 12345678910111213const Counter = (&#123; value &#125;) =&gt; ( &lt;h1&gt;&#123;value&#125;&lt;/h1&gt;);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125;/&gt;, document.getElementById('root') );&#125;;store.subscribe(render);render(); 上面是一个简单的计数器，唯一的作用就是把参数value的值，显示在网页上。Store 的监听函数设置为render，每次 State 的变化都会导致网页重新渲染。下面加入一点变化，为Counter添加递增和递减的 Action。1234567891011121314151617181920212223242526272829const Counter = (&#123; value &#125;) =&gt; ( &lt;h1&gt;&#123;value&#125;&lt;/h1&gt; &lt;button onClick=&#123;onIncrement&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;onDecrement&#125;&gt;-&lt;/button&gt;);const reducer = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; &#125;&#125;;const store = createStore(reducer);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125; onIncrement=&#123;() =&gt; store.dispatch(&#123;type: 'INCREMENT'&#125;)&#125; onDecrement=&#123;() =&gt; store.dispatch(&#123;type: 'DECREMENT'&#125;)&#125; /&gt;, document.getElementById('root') );&#125;;render();store.subscribe(render); 推荐如何用 fis3 来开发 React?fis3 react redux todo demo中文文档 GitHub基于 react + react-router + redux + webpack + ES6/7 + less 的完整项目]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git 常用命令]]></title>
      <url>%2F2017%2F02%2F13%2Fgit-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[git 常用命令 git 如何删除本地创建的仓库12//删除文件夹下的所有 .git 文件find . -name ".git" | xargs rm -Rf 本地仓库与远程仓库建立关联1$ git remote add origin git@github.com:djqiang/gitdemo.git 提示出错信息：fatal: remote origin already exists 解决办法如下：12$ git remote rm origin$ git remote add origin git@github.com:djqiang/gitdemo.git]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端模块化]]></title>
      <url>%2F2017%2F02%2F13%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
      <content type="text"><![CDATA[前端模块化这篇文章很好，看了好多遍，转过来以后不会迷路了在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀 这时候JavaScript作为嵌入式的脚本语言的定位动摇了，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块（module）了，JavaScript极其简单的代码组织规范不足以驾驭如此庞大规模的代码 模块既然JavaScript不能handle如此大规模的代码，我们可以借鉴一下其它语言是怎么处理大规模程序设计的，在Java中有一个重要带概念——package，逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的，那么外部如果使用呢？直接import对应的package即可 import java.util.ArrayList;遗憾的是JavaScript在设计时定位原因，没有提供类似的功能，开发者需要模拟出类似的功能，来隔离、组织复杂的JavaScript代码，我们称为模块化。 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，各行其是就都乱套了 规范形成的过程是痛苦的，前端的先驱在刀耕火种、茹毛饮血的阶段开始，发展到现在初具规模，简单了解一下这段不凡的历程 函数封装我们在讲函数的时候提到，函数一个功能就是实现特定逻辑的一组语句打包，而且JavaScript的作用域就是基于函数的，所以把函数作为模块化的第一步是很自然的事情，在一个文件里面编写几个相关函数就是最开始的模块了 function fn1(){ statement} function fn2(){ statement}这样在需要的以后夹在函数所在文件，调用函数就可以了 这种做法的缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。 对象为了解决上面问题，对象的写法应运而生，可以把所有的模块成员封装在一个对象中 var myModule = { var1: 1, var2: 2, fn1: function(){ }, fn2: function(){ } }这样我们在希望调用模块的时候引用对应文件，然后 myModule.fn2();这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系 看似不错的解决方案，但是也有缺陷，外部可以随意修改内部成员 myModel.var1 = 100;这样就会产生意外的安全问题 立即执行函数可以通过立即执行函数，来达到隐藏细节的目的 var myModule = (function(){ var var1 = 1; var var2 = 2; function fn1(){ } function fn2(){ } return { fn1: fn1, fn2: fn2 }; })();这样在模块外部无法修改我们没有暴露出来的变量、函数 上述做法就是我们模块化的基础，目前，通行的JavaScript模块规范主要有两种：CommonJS和AMD CommonJS我们先从CommonJS谈起，因为在网页端没有模块化编程只是页面JavaScript逻辑复杂，但也可以工作下去，在服务器端却一定要有模块，所以虽然JavaScript在web端发展这么多年，第一个流行的模块化规范却由服务器端的JavaScript应用带来，CommonJS规范是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。 定义模块根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性 模块输出：模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象 加载模块：加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象 看个例子 //模块定义 myModel.js var name = ‘Byron’; function printName(){ console.log(name);} function printFullName(firstName){ console.log(firstName + name);} module.exports = { printName: printName, printFullName: printFullName} //加载模块 var nameModule = require(‘./myModel.js’); nameModule.printName();不同的实现对require时的路径有不同要求，一般情况可以省略js拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块） 尴尬的浏览器仔细看上面的代码，会发现require是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。 这在服务器端实现很简单，也很自然，然而， 想在浏览器端实现问题却很多。 浏览器端，加载JavaScript最佳、最容易的方式是在document中插入script 标签。但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载。 解决思路之一是，开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。 这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。 另一种解决思路是，用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生的分歧： AMDAMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范 由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出 requireJS主要解决两个问题 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长看一个使用requireJS的例子 // 定义模块 myModule.jsdefine([‘dependency’], function(){ var name = ‘Byron’; function printName(){ console.log(name); } return { printName: printName }; }); // 加载模块require([‘myModule’], function (my){ my.printName();}); 语法 requireJS定义了一个函数 define，它是全局变量，用来定义模块 define(id?, dependencies?, factory);id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）dependencies：是一个当前模块依赖的模块名称数组factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值在页面上使用require函数加载模块 require([dependencies], function(){});require()函数接受两个参数 第一个参数是一个数组，表示所依赖的模块第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 CMDCMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同 语法 Sea.js 推崇一个模块一个文件，遵循统一的写法 define define(id?, deps?, factory)因为CMD推崇 一个文件一个模块，所以经常就用文件名作为模块idCMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写factory有三个参数 function(require, exports, module)require require 是 factory 函数的第一个参数 require(id)require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口 exports exports 是一个对象，用来向外提供模块接口 module module 是一个对象，上面存储了与当前模块相关联的一些属性和方法 demo // 定义模块 myModule.jsdefine(function(require, exports, module) { var $ = require(‘jquery.js’) $(‘div’).addClass(‘active’);}); // 加载模块seajs.use([‘myModule.js’], function(my){ }); AMD与CMD区别关于这两个的区别网上可以搜出一堆文章，简单总结一下 最明显的区别就是在模块定义时对依赖的处理不同 AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块CMD推崇就近依赖，只有在用到某个模块的时候再去require这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法 AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同 很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略 为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。） 同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行 CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的 这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因 转自：博客园]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[迎接我的新Mac]]></title>
      <url>%2F2017%2F02%2F11%2F%E8%BF%8E%E6%8E%A5%E6%88%91%E7%9A%84%E6%96%B0mac%2F</url>
      <content type="text"><![CDATA[迎接我的新Mac 2016 Touch Bar 16年一直想换新款Mac，也在准备钱 时间很快，17年终于把钱准备够了，终于可以淘汰掉手里这款，说实话15款没任何毛病，也就是16款是新款的原因吧就是想换，于是今天元宵节去实体店取了新款Mac，每次出入店铺的时间都不足十分钟，这些电子产品没什么可考虑的 和以往不同的是这次买了电脑没有当场激活，以防止后悔 都说新版Mac键程短，我用这其实没什么，也不会打错字 嗯，就酱…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端学习路线]]></title>
      <url>%2F2017%2F02%2F09%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
      <content type="text"><![CDATA[前端学习路线 前言我为什么学习前端？当初还小，不知道以后做什么，思想不断成熟，觉得该学一些本事找工作了，只因在微博校园校内实习，对甘肃农业大学的微博大厅和H5微场景感兴趣就决定开始学习前端；后来也做了两个demo当时满满的成就感下面就让我们瞧瞧这两个demo 微博大厅 H5 更新这篇博客时我在哪？2017-02-09 20:17:51这个时间点我已经大四快要毕业了，也正是寒假，辞掉了北京的实习回到哈尔滨； 学习路线以下学习路线是我转载的，也是我的学习路线入行行头：5大硬件12345一颗人类的大脑：智商在平均水平线以上即可一份强烈的渴望：我的代码要可以运行在任何一个有浏览器的设备上一台笔记本电脑：不需要花费很多钱得那种，当然你也可以只用一台台式机，但是那样就不能带着它坐在咖啡馆里...一个文本编辑器：可以推荐的比如 Visual Studio Code，Brackets一个翻墙代理：这个大家都懂的，我就不解释了 初级资质（比如我）12你需要学会浏览器能理解的三大语言：HTML, CSS, Javascript 神圣的三位一体！非常重要的一点是，一定要理解这三大语言后再去学习别的，确保知道怎样在各种尺寸的屏幕上排列好你的网页，怎样在一个按钮被按下后 do something! 中级进阶路径（这些我好像已经会了）一旦掌握了三大语言，就可以开始学习专业的开发流程啦：1234567Command line：好吧,命令行也许都会,但是要掌握最基本的操作,熟悉怎样配置你的环境,还有那些奇怪的 shell 脚本，因为你会经常用到它们CSS 已经不够用了,我们有了 CSS 的预处理：Sass, LESS知道如何搭建一个 build 系统：Gulp 或 Grunt 这类的构建任务脚本器,编译 LESS 成 CSS, concatenating Javascript, minify 压缩静态资源, 选一个异步或同步的方式加载它们，然后一个好的 build 系统要能自动做到那些,包括一个本地的 web 服务器用于测试代码代码版本管理，git在 github 上分享你的代码！部署! 让你的网站上线。可以找一个免费的服务提供商，比如本博托管在https://pages.github.com这些几乎就是现代前端开发者会用到的工具和技术，好了，你现在可以成为一个前端开发工程师了 高级炸裂装备（不断学习）12345你已经能够为你的朋友的业务搭建一个网站了，简洁的排版，高清大照片，你成功了，它甚至在你的手机都看着很棒。那么还有什么值得学的？把你的网站和一个内容管理系统 (CMS）集成在一起。一个 CMS 能够让你通过用户界面增、删、改、组织你的内容，不需要任何代码。这就是那些博客网站如何工作的。比如免费的 WordPress，去熟悉一个开源的 CMS 吧，会很有用的学习怎样搭建一个 CMS，意味着你讲要熟悉一个服务器端的语言，比如 Node.js, 或 PHP，然后你还会想要知道怎样和数据库打交道，比如 MySql 或者 MongoDB来熟悉一种 Javascript 框架吧，这样你可以真正的搭建一个交互出色的 web 应用，那真的很重要，比如 Angular, React, Ember。只要挑一个你喜欢的，但是一定要精通它Javascript design patterns，javascript 也有设计模式？ 是的，读一下吧 突破天际的大招1234567沟通技巧！你需要和你的小伙伴们沟通，他们是你的 coder 伙伴，你的老板，你的用户，你的....stackoverflow.com， 有问题找 stackoverflow，扩展一下人脉把，上 meetup.com, 在博客上写一些你的学习体验， 在 Gitgub 贡献一下你的 Pull request界面设计和用户体验设计 UI/UX design，前段开发的小伙伴需要具备基本的 UI/UX 设计知识搜索优化，要知道怎样提高网站的搜索排名，更容易被人们搜索到CSS 过度效果，给你的按钮写一个 hover 的 CSS 动画，还有你的从右边滑入的导航菜单也需要一个平滑的动画关于性能，让你的网站尽可能快的被加载，减少 DOM 的 reflow 和 repaint 操作，防止滚动性能瓶颈，优化 Javascript, 翻墙读一读这个吧 google web developer fundamentals用一些测试框架来实现 Javascript 单元测试，比如 Jasmine，QUnit持续集成 Continuous integration (CI)，知道怎样配置一套和伙伴们一起使用的自动测试和部署的工具，比如 CircleCI, Travis CI, Jenkins 超好用的其他加成技能12用 CSS3, SVG, Canvas API 实现动画后端开发， Node.js 最后：去找工作吧！1234567有了技能是不够的，你需要能展示它们，你还能干的是：搭建一个小网站，公开你的 github 代码库，确保你的代码和文档清楚漂亮，还有一份 README去 meetup.com 找你的老板或者投资人吧，开一个博客，申请一个 linkedin 帐号因为 web 技术总是在变化，最后，即使找到了一份称心的工作，还是需要 stay motivated, 你需要时常去下面这些地方转转：CSS Tricks，SitePoint，Smashing Magazine当然还有些像 CSDN 这样中文社区，总之遇到任何难题，社区里有总有乐于助人的保持好的职业态度：Stay humble, and build cool shit]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前后端项目技术方案]]></title>
      <url>%2F2017%2F02%2F09%2Fsolution%2F</url>
      <content type="text"><![CDATA[简单前后端项目技术方案明天年会，今晚部门开了个晚会刚到住处多久，还在百度实习，想记录点东西；我项目中没用到这些，介于我有代码权限所以以下的东西从其他项目中学过来的！自己研究了好久，因为环境配置，思路梳理很慢。 简单前后端项目技术方案 2017-1-10前端：12345构建：Fis3结构：HTML,TMPL,Smarty样式：Less框架：....util：.... 后端：1PHP-CI,Smarty,MySql 补充：构建工具 Fis3JS 模板 Tmpl基于Smarty的解决方案 Fis SmartyCI Smarty 融合方法 注： 以上TMPL,Smarty 都是用Fis集成的狼厂后端PHP有用的是ODP了解的可以去搞一下，我这里使用CI融合的Smarty我的MD语法掌握不太好！所以写的丑了点~ 看了这么多？直奔主题：graduation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Fis3+Es6+Smarty+Tmpl 项目实战]]></title>
      <url>%2F2017%2F02%2F09%2Ffis3-es6-smarty-tmpl-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F</url>
      <content type="text"><![CDATA[Fis3+Es6+Smarty+Tmpl 项目实战毕业设计代码，还没完成！但可以跑哦~虽说技术稍微过时，但是自己也摸索了好久，是学习新技术的基础 前端阅读以下部分假定你已经了解： 构建工具 Fis3 基于Smarty的解决方案 Fis-Smarty 一些杂碎 Less, Tmpl, Es6 … 微薄网站的设计与实现 功能 展示，留言，评论，评论量，访问量 后台CMS 瀑布流展示,懒加载数据 接入微博组件等 技术方案 构建: Fis3 结构: HTML,TMPL,Smarty 样式: Less 类库/框架: jQuery util: urlParam … 数据: 假数据模拟，后期发布开发机联调 目录结构前端目录1234567891011121314151617181920└─graduation ├─ README.md ├─ home └─ common ├─ plugin # Smarty 的插件放入这个目录 ├─ smarty.conf # 本地测试的 Smarty 引擎的配置文件 ├─ fis-conf.js # fis3 的配置文件 ├─ page # 放一些页面 ├─ server.conf # 本地测试的URL转发规则配置文件 ├─ static # 非组件静态资源 ├─ test # 假数据 └─ widget # 放一些 widget，里面代码最终会被组件化封装 ├─ header # 头部模块 │ ├─ header.js # js文件es6 │ ├─ header.less # css预处理 │ ├─ header.tmpl # JS模板 │ └─ header.tpl # Smarty 复用还是挺方便的 ├─ nav # 导航模块 ├─ article # 文章模块 └─ footer # 尾部模块 目录文件不是都必须需要，一般都会包含page、widget俩目录 发布发布到本地模拟开发机，并预览该项目 修改 fis-global-conf.js123const RECEIVER = 'http://127.0.0.1/graduation-rd/receiver.php';const to_path = '/graduation-rd';const base_url = '/Applications/XAMPP/xamppfiles/htdocs/graduation-rd/'; 安装12npm install -g fis3npm install -g fis3-smarty 后端环境下载 启动123fis3 release -r common xuechengfis3 release -r home xuecheng fis3 release -r ... 发布成功后目录123456789101112└─ htdocs └─graduation-rd ├── application ├── home.php ├── license.txt ├── receiver.php ├── system ├── user_guide ├── template # .tpl 发布位置 ├── static # 静态资源发布位置 ├── plugin # plugin/*.php 发布位置 └── config # config/*.json 发布位置 上线 V1.1 第一版 v1.4 引入微博组件 v1.5 封装分页组件 v1.6 解决严格模式bdtmpl问题 所有版本 参考 代码风格: clean-code-javascript ES6: ruanyifeng 感谢 yanhaijing Google]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于这个博客]]></title>
      <url>%2F2017%2F02%2F09%2F%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[基于HEXO的博客最近才弄的，一直想有一个自己的博客，这个维护成本低，所以以后打算用它写点东西之前的个人网站仅仅是为了毕业设计而做的；]]></content>
    </entry>

    
  
  
</search>
